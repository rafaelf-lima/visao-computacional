# -*- coding: utf-8 -*-
"""Visão Computacional - Tarefa 02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZN4xf7B-jD2z6aUIWLu-f7LGdX2Droed
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
# %matplotlib inline

def carregar_imagem(caminho):
    imagem = Image.open(caminho).convert('L')
    return np.array(imagem)

def mostrar_imagem(imagem, titulo='Imagem'):
    plt.imshow(imagem, cmap='gray')
    plt.title(titulo)
    plt.axis('off')
    plt.show()

def aplicar_padding(imagem, tamanho_kernel):
    pad = tamanho_kernel // 2
    return np.pad(imagem, pad, mode='constant')

def filtro_media(imagem, tamanho_kernel=3):
    pad = tamanho_kernel // 2
    kernel = np.ones((tamanho_kernel, tamanho_kernel)) / (tamanho_kernel**2)

    imagem_pad = aplicar_padding(imagem, tamanho_kernel)
    imagem_saida = np.zeros_like(imagem)

    for i in range(imagem.shape[0]):
        for j in range(imagem.shape[1]):
            regiao = imagem_pad[i:i+tamanho_kernel, j:j+tamanho_kernel]
            imagem_saida[i, j] = np.sum(regiao * kernel)

    return imagem_saida.astype(np.uint8)

def filtro_mediana(imagem, tamanho_kernel=3):
    pad = tamanho_kernel // 2
    imagem_pad = aplicar_padding(imagem, tamanho_kernel)
    imagem_saida = np.zeros_like(imagem)

    for i in range(imagem.shape[0]):
        for j in range(imagem.shape[1]):
            regiao = imagem_pad[i:i+tamanho_kernel, j:j+tamanho_kernel]
            imagem_saida[i, j] = np.median(regiao)

    return imagem_saida.astype(np.uint8)

def detectar_bordas(imagem, tamanho_kernel=3):
    imagem_suavizada = filtro_media(imagem, tamanho_kernel)
    bordas = imagem.astype(int) - imagem_suavizada.astype(int)
    return np.clip(np.abs(bordas), 0, 255).astype(np.uint8)

def reforcar_bordas(imagem, tamanho_kernel=3):
    imagem_suavizada = filtro_media(imagem, tamanho_kernel)
    realcada = 2 * imagem.astype(int) - imagem_suavizada.astype(int)
    return np.clip(realcada, 0, 255).astype(np.uint8)

def erosao(imagem, tamanho_kernel=3):
    pad = tamanho_kernel // 2
    imagem_pad = aplicar_padding(imagem, tamanho_kernel)
    imagem_saida = np.zeros_like(imagem)

    for i in range(imagem.shape[0]):
        for j in range(imagem.shape[1]):
            regiao = imagem_pad[i:i+tamanho_kernel, j:j+tamanho_kernel]
            imagem_saida[i, j] = np.min(regiao)

    return imagem_saida.astype(np.uint8)

def dilatacao(imagem, tamanho_kernel=3):
    pad = tamanho_kernel // 2
    imagem_pad = aplicar_padding(imagem, tamanho_kernel)
    imagem_saida = np.zeros_like(imagem)

    for i in range(imagem.shape[0]):
        for j in range(imagem.shape[1]):
            regiao = imagem_pad[i:i+tamanho_kernel, j:j+tamanho_kernel]
            imagem_saida[i, j] = np.max(regiao)

    return imagem_saida.astype(np.uint8)

caminho_imagem = 'exemplo.jpg'
imagem_original = carregar_imagem(caminho_imagem)
mostrar_imagem(imagem_original, 'Original')

imagem_blur = filtro_media(imagem_original, 5)
imagem_mediana = filtro_mediana(imagem_original, 5)

bordas = detectar_bordas(imagem_original, 5)
realcada = reforcar_bordas(imagem_original, 5)

erodida = erosao(imagem_original, 3)
dilatada = dilatacao(imagem_original, 3)

mostrar_imagem(imagem_blur, 'Filtro da Média')
mostrar_imagem(imagem_mediana, 'Filtro da Mediana')
mostrar_imagem(bordas, 'Bordas Detectadas')
mostrar_imagem(realcada, 'Bordas Reforçadas')
mostrar_imagem(erodida, 'Erosão')
mostrar_imagem(dilatada, 'Dilatação')